# 计算机科学速成课 Crash Course Computer Science

### 第二十七集 3D图形 3D Graphics

可以写一个函数从A到B画一条线，通过控制A和B的（X,Y）坐标可以控制一条线，在3D图像中，点的坐标不再是两点，而是三点：X,Y,Z。在2D的电脑屏幕上不可能有XYZ立体坐标轴，所以有图形算法负责把3D坐标显示到2D屏幕上，这叫“3D投影”（3D projection）。

#### 线框渲染

所有的点都从3D转成2D后，就可以用画2D线段的函数来连接这些点，这叫“线框渲染”（Wireframe Rendering）。3D投影有好几种：

正交投影（orthographic projection）：立方体的各个边在投影中互相平行。

![image-20200228231449493](https://github.com/WilliamWuLH/My-notes-about-CCCS/blob/master/image/image-20200228231449493.png)

透视投影（perspective projection）：在真实3D世界中，平行线段会在远处收敛于一点。

![image-20200228231822468](https://github.com/WilliamWuLH/My-notes-about-CCCS/blob/master/image/image-20200228231822468.png)

在3D图形学中，三角形等称为“多边形”（polygons），一堆多边形的集合叫网格（mesh）。网格越密，表面越光滑，细节越多，意味着更多的计算量。游戏设计者要平衡角色的真实度和多边形数量，如果数量太多，帧率会下降到肉眼可感知，用户会觉得卡顿，因此有算法用来简化网格。

之所以三角形更常用而不是用正方形或是其他更复杂的图形，是因为三角形的简单性。在空间中三点定义一个平面，如果给3个3D点，我们可以画出一个平面，并且只有一个答案（一个唯一确定的平面）。4个或者更多就不一定了，而2个点不够定义平面，只能定义线段，所以3是perfect。

#### 扫描线渲染

3D图像需要填充，填充图形的经典算法叫扫描线渲染（Scanline Rendering）于1967年诞生于犹他州大学，要完成多边形转成一块填满像素的区域，首先铺一层像素网格，扫描线算法先读多边形的3个点，找最大和最小的Y值，只在这两点间工作，然后算法从上往下，一次处理一行，计算每一行和多边形相交的2个点，因为是三角形，如果相交一条边，必然相交另一条边，扫描线算法会填满2个相交点之间的像素。填充的速度叫填充速率（fillrate）。

![image-20200229012551868](https://github.com/WilliamWuLH/My-notes-about-CCCS/blob/master/image/image-20200229012551868.png)

#### 抗锯齿

这样的三角形比较丑，边缘全是锯齿，当像素较小时就不会很明显。一种减轻锯齿的方法叫抗锯齿（Antialiasing），与其每个像素都涂成一样的颜色，可以判断多边形切过像素的程度来调整颜色。如果像素在多边形内部就直接涂色，如果多边形划过像素则颜色就浅一些，这种边缘羽化的效果看着会更舒服。

![image-20200229013211053](https://github.com/WilliamWuLH/My-notes-about-CCCS/blob/master/image/image-20200229013211053.png)

#### 画家算法

抗锯齿被广泛使用，比如字体和图标。在3D场景中，多边形到处都是，但是只有一部分能看见，因为其他的被挡住了，这叫遮挡（occlusion）。最直接的处理方法是用排序算法，从远到近排列，然后从远到近渲染，这叫画家算法（painter‘s algorithm）。

#### 深度缓冲

还有一种方法叫做深度缓冲（Z-Buffering），这个算法不用排序所以速度更快，Z-Buffering算法会记录场景中每个像素和摄像机的距离，在内存里存一个数字矩阵，首先，每个像素的距离被初始化为“无限大”，然后Z-Buffering从列表里第一个多边形开始处理，它和扫描线算法逻辑相同，但不是给像素填充颜色，而是把多边形的距离和Z-Buffering里的距离进行对比，它总是记录更低的值，以此类推，因为没对多边形排序，所以后处理的多边形并不会总是覆盖前面的。Z-Buffering缓冲区完成之后，会和扫描线算法的改进高级版配合使用，不仅可以勘测到线的交叉点，还可以知道某像素是否在最终场景中可见。

![image-20200229014523153](https://github.com/WilliamWuLH/My-notes-about-CCCS/blob/master/image/image-20200229014523153.png)

#### 背面剔除

3D游戏中有个优化叫做背面剔除（Back-Face Culling），三角形有背面和正面两面，游戏角色的头部或地面只能看到朝外的一面，所以为了节省处理时间往往会忽略多边形背面，减了一半多边形面数。

#### 明暗处理——平面着色，高洛德着色，冯氏着色

讲到灯光会有明暗处理（shading），因为3D场景中物体表面应该会有明暗变化，我们需要考虑物体上这些多边形面对的方向，它们不平行于屏幕，而是面对不同方向，它们面对的方向叫“表面法线”（surface normal），可以用一个垂直于表面的小箭头来显示这个方向，加个光源后每个多边形被照亮的程度不同，因为面对的角度导致更多光线反射到观察者。按照不同亮度对多边形进行染色叫做平面着色，这是最基本的照明算法，这使得多边形的边界非常明显，看起来不光滑，因此开发了更多算法，比如高洛德着色（Gouraud Shading）和冯氏着色（Phong Shading），不只用一种颜色给整个多边形上色，而是以巧妙的方式改变颜色以得到更好的效果。

#### 纹理映射

纹理（textures）在图形学中指外观而不是手感，纹理也有多种算法来做各种花哨效果，最简单的是纹理映射（texture mapping），在用扫描线算法填充单个多边形时，可以看看内存内的纹理图像决定像素用什么颜色，为了做到这点，需要把多边形坐标和纹理坐标对应起来。在扫描线算法填充像素时，纹理算法会查询纹理，从相应区域取平均颜色并填充多边形，重复这个过程就可以获得纹理。

![image-20200229123130737](https://github.com/WilliamWuLH/My-notes-about-CCCS/blob/master/image/image-20200229123130737.png)

#### GPU

有几种方法可以加速渲染，首先我们可以为这种特定算法做专门的硬件来加快速度；其次可以把3D场景分解成多个小部分，然后并行渲染，而不是按顺序渲染。计算机工程师为图形做了专门的处理器，叫图形处理单元（Graphics Processing Unit——GPU）。GPU在显卡上，周围有专用的RAM，所有网格和纹理都在里面，让GPU的多个核心可以高速访问。

现代显卡，如GeForce GTX 1080 Ti有3584个处理核心，提供大规模并行处理，每秒处理上亿个多边形。
